У функции есть 2 фазы жизненного цикла: cоздание функции (определение) и выполнение.
Выполнение делится на две фазы – вход в контекст выполнения, но до построчного выполнения кода
и само выполнение каждой строки.

Итак, каждый раз, когда происходит передача управления исполняемому коду ECMAScript-программы, осуществляется вход в контекст исполнения.

Логически, совокупность контекстов исполнения представляет собой стек. Дно этого стека — всегда глобальный контекст, верхушка — текущий (активный) контекст исполнения. Стек модифицируется (наполняется/очищается) по мере входа в различные виды EC.

Каждый возврат из функции завершает текущий контекст исполнения.

Так как, переменные связаны с контекстом исполнения, последний должен знать, где хранятся его данные и как их получить. Данный механизм называется Объектом переменных.

Объект переменных (Variable object, сокращённо VO) – это связанный с контекстом исполнения объект, служащий хранилищем для:
 - переменных (var);
 - деклараций функций (FunctionDeclaration, сокращённо FD);
 - формальных параметров функции
объявленных в данном контексте.

            activeExecutionContext = {
                VO: {
                    // данные контекста (var, FD, параметры функций)
                }           
            };

Объект активации (Activation object, сокращённо AO) — специальный объект, который создаётся при входе в контекст функции и инициализируется свойством arguments

            AO = {
                arguments: {
                    callee: ... , // ссылка на выполняемую функцию
                    length: ... , // кол-во реально переданных параметров
                    свойства-индексы
                }
            }

    ДЕТАЛИЗАЦИЯ ОБРАБОТКИ КОДА КОНТЕКСТА

Обработка кода контекста исполнения делится на два основных этапа:
 - Вход в контекст исполнения;
 - Непосредственно, интерпретация кода.
С этими двумя этапами тесно связана модификация объекта переменных.    

    ВХОД В КОНТЕКСТ ИСПОЛНЕНИЯ
При входе в контекст исполнения (но до построчного выполнения его кода), VO наполняется следующими свойствами:

для каждого формального параметра функции (если мы находимся в контексте исполнения функции)
 - создаётся свойство VO с именем и значением формального параметра; для непереданных параметров – создаётся свойство VO с именем формального параметра и значением undefined;

для каждой декларации функции (FunctionDeclaration, FD)
 - создаётся свойство VO, с именем функции и значением, являющимся ссылкой на объект-функцию; если в VO уже присутствовало свойство с таким именем, оно его значение и атрибуты заменяются значением функции;

для каждой переменной (var)
 - создаётся свойство VO с именем переменной, и значением undefined; если в VO уже присутствовало свойство с таким именем, оно остаётся нетронутым.


классический пример:

            alert(x); // function
            
            var x = 10;
            alert(x); // 10
            
            x = 20;
            
            function x() {}
            
            alert(x); // 20

Почему в первом выводе “x” — функция, да ещё и доступна до объявления? Почему не 10 и не 20? Потому что, согласно правилу – VO наполняется декларациями функций ещё при входе в контекст, там же, при входе, встречается объявление переменной “x”, но переменные в VO имеют более низкий приоритет, нежели декларации функций.

В примере ниже, мы снова видим, что переменные попадают в VO ещё при входе в контекст (так, блок else никогда не выполнится, но, тем не менее, переменная “b” существует в VO):

            if (true) {
                var a = 1;
            } else {
                var b = 2;
            }
            
            alert(a); // 1
            alert(b); // undefined, но не "b is not defined"


Отличия при объявлении переменных с var и без var:

            alert(a); // undefined, понятно почему
            alert(b); // "b" is not defined

            b = 10;
            alert(b); // 10, создалось при исполнении
            
            var a = 20;
            alert(a); // 20, модифицировалось при исполнении

Ещё один важный момент относительно переменных. Переменные, в отличии от простых свойств, получают атрибут {DontDelete}, означающий невозможность удалить свойство посредством оператора delete:

            a = 10;
            alert(window.a); // 10
            
            alert(delete a); // true
            
            alert(window.a); // undefined
            
            var b = 20;
            alert(window.b); // 20
            
            alert(delete b); // false
            
            alert(window.b); // по-прежнему, 20