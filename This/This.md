http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this  
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions  

Значение this напрямую связанно с типом исполняемого кода контекста. Определяется оно при входе в контекст и на протяжении исполнения кода контекста, является неизменным.

                                        activeExecutionContext = {
                                            VO: {...},    // объект переменных (variable object)
                                            this: thisValue
                                        };


    THIS В ГЛОБАЛЬНОМ КОДЕ
Здесь довольно всё просто. В коде глобального контекста, значением this всегда является сам глобальный объект (global); таким образом, можно косвенно к нему обратиться:

                                        // явное объявление свойства глобального объекта
                                        this.a = 10; // global.a = 10
                                        alert(a); // 10
                                        
                                        // косвенное, посредством присваивания
                                        // неопределённому до этого идентификатору
                                        b = 20;
                                        alert(this.b); // 20
                                        
                                        // также косвенное, посредством объявления
                                        // переменной, поскольку объектом переменных
                                        // в глобальном контексте является сам глобальный объект
                                        var c = 30;
                                        alert(this.c); // 30    

    THIS В КОДЕ ФУНКЦИИ
В коде функции this не связано статично с функцией. this определяется при входе в контекст, и в случае с кодом функции, каждый раз может быть абсолютно разным.
При обычном вызове функции, this определяется вызывающей стороной, которая активирует код контекста функции, — так называемый, caller, т.е. родительский контекст, который вызывает функцию. Определение значения this происходит по форме выражения вызова (иными словами, как синтаксически вызвана функция).

Обычную глобальную функцию можно активировать разными формами вызова, которые и влияют на разное значение this:

                                        function foo() {
                                            alert(this);
                                        }
                                        
                                        foo(); // global
                                        
                                        alert(foo === foo.prototype.constructor); // true
                                        
                                        // но при иной форме вызова той же
                                        // функции, this будет иметь уже другое значение
                                        
                                        foo.prototype.constructor(); // foo.prototype

Аналогично можно вызвать функцию, описанную как метод объекта, но значением this не будет являться этот объект:

                                        var foo = {
                                        bar: function () {
                                            alert(this);
                                            alert(this === foo);
                                        }
                                        };
                                        
                                        foo.bar(); // foo, true
                                        
                                        var exampleFunc = foo.bar;
                                        
                                        alert(exampleFunc === foo.bar); // true
                                        
                                        // опять же, при иной форме вызова той же
                                        // функции, this уже установлен в другое значение
                                        
                                        exampleFunc(); // global, false

ВЫЗОВ ФУНКЦИИ И НЕ ТИП REFERENCE
когда слева от скобок вызова находится значение не типа Reference, а любого другого типа, значение this будет автоматически определенно как null, и, как следствие, global.

                                        (function () {
                                            alert(this); // null => global
                                        })();
В данном случае мы имеем объект Function, но не объект типа Reference (это не идентификатор и не выражение доступа к свойству), соответственно, значение this в конечном итоге будет определенно, как глобальный объект.

Примеры сложнее:
                                        
                                        var foo = {
                                            bar: function () {
                                                alert(this);
                                            }
                                        };
                                        
                                        foo.bar(); // Reference, OK => foo
                                        (foo.bar)(); // Reference, OK => foo
                                        
                                        (foo.bar = foo.bar)(); // global?
                                        (false || foo.bar)(); // global?
                                        (foo.bar, foo.bar)(); // global?

Во втором случае применяется оператор группировки, который не вызывает, рассмотренный выше, метод получения реального значения объекта из значения типа Reference, т.е. GetValue.
В третьем случае, оператор присваивания, в отличие от оператора группировки, вызывает метод GetValue. В итоге на выходе уже будет значения типа Function, означающее, что в качестве this будет использован null и, как следствие, global.

Аналогично с четвертым и пятым случаями — оператор запятая и логическое ИЛИ вызывают GetValue, соответственно, мы теряем значение типа Reference и получаем значение типа Function; вновь,this определён как global.


ТИП REFERENCE И ЗНАЧЕНИЕ THIS РАВНОЕ NULL

Существует ситуация, когда выражение вызова определит слева от скобок вызова значение типа Reference, однако значение this будет определено как null и, как следствие, global.
Это относится к случаю, когда базовым объектом значения типа Reference, является объект активации.

                                        function foo() {
                                            function bar() {
                                                alert(this); // global
                                            }
                                            bar(); // равносильно AO.bar()
                                        }

Объект активации всегда возвращает в качестве значения this — null

Аналогичная ситуация должна быть с активацией функции, являющейся параметром выражения catch: в данном случае объект catch также добавляется перед объектом активации, либо глобальным объектом. Однако, данное поведение было определенно как баг ECMA-262-3 и исправлено в новой версии стандарта ECMA-262-5; таким образом, значение this в данной активации должно быть global, но не объект catch:

                                        try {
                                            throw function () {
                                                alert(this);
                                            };
                                        } catch (e) {
                                            e(); // __catchObject - в ES3, global - исправлено в ES5
                                        }
 
Та же самая ситуация с рекурсивным вызовом именованной функции-выражения. При первой активации функции, базой является родительский объект активации (или глобальный объект), при последующих — базой должен быть специальный объект хранящий имя функции-выражения. Однако, в данном случае в качестве this также всегда используется global:

                                        (function foo(bar) {
                                            alert(this);
                                            !bar && foo(1); // "должен" быть спец.объект, но всегда global
                                        })(); // global

THIS ПРИ ВЫЗОВЕ ФУНКЦИИ В КАЧЕСТВЕ КОНСТРУКТОРА
При вызове функции с использованием ключевого слова new функция выступает в роли конструктора, и this указывает на создаваемый объект. 

                                        function A() {
                                            alert(this); // вновь сознанный объект, ниже - объект "a"
                                            this.x = 10;
                                        }
                                        
                                        var a = new A();
                                        alert(a.x); // 10

**В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.**

                                    'use strict';
                                    var obj = {
                                    i: 10,
                                    b: () => console.log(this.i, this),
                                    c: function() {
                                        console.log(this.i, this);
                                    }
                                    }

                                    obj.b(); // prints undefined, Window {...} (или глобальный объект)
                                    obj.c(); // prints 10, Object {...}

obj.b() - undefined, т.к. у стрелочных функций нету своего this. this находится в VO или AO(в глобальном контексте исполнения или контексте исполнения функции соответственно), а в объекте нету this. Следовательно this стрелочной функции сначала будет искаться в стрелочной функции, потом в объекте obj и только потом в глобальном объекте.